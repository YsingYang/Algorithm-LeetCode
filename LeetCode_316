class Solution {
/***
 * first solution,贪心准则，
 * 每次寻找一个最小的，且能覆盖后续所有字符的字符，
 * 得到后，下一次的begin就是该字符，算法时间复杂度为O（26*26Klogn）
 * 思路简单，但算法并不高校，空间复杂度为O(N）
 */
public:
    string removeDuplicateLetters(string s) {
        map<char,set<int>> mp;
        string res;
        for(int i=0;i<s.size();++i){
            mp[s[i]].insert(i);
        }
        int beginIndex = 0;
        while(!mp.empty()){
            for(auto it:mp){
                int idx = *it.second.lower_bound(beginIndex);//大于等于beginIndex的第一个数
                if(canCover(idx,it.first,mp)){
                    res += it.first;
                    mp.erase(it.first);
                    beginIndex  = idx;
                    break;
                }
            }
        }
        return res;
    }
    
    bool canCover(int idx,char c,map<char,set<int>> &mp){
        for(auto it:mp){
            if(it.first == c)
                continue;
            if(*it.second.rbegin()<idx){
                return false;
            }
        }
        return true;
    }
};
