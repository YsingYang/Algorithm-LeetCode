/*
    想了很多方法得到的都是worse ansewer,准备来说，应该是边界把握不足的原因，
    
    该方法主要是将边界一次性的全部push仅priority_queue中，当做这一cell的边界，同时，pop出第一个高度最小的，开始BFS搜索，
    对pop出来的点搜索4周的点，如果如果比当前的小（应该pop出的是最小的点，不用考虑最外层边界的问题）res = n->height - heightMap[row][col])<0?0:n->height-heightMap[row][col],同时，push 进新的点，（注意！）新的点的高度为max(height,与heightMap[row][col]的高度)，而不当当只是当前测试点的高度，毕竟边界还是没有变化的。但如果该点比边界高，会组成新的边界


*/



class Solution {
class node;
using sp = shared_ptr<node>;
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        if(heightMap.empty())
            return 0;
        rs= heightMap.size(),cs = heightMap[0].size();
        vector<vector<bool>> visited(rs,vector<bool>(cs,false));
        vector<vector<int>> direction = {{1,0},{0,1},{-1,0},{0,-1}};
        priority_queue<sp,vector<sp>,compare> pq;
        int res = 0;
        
        for(int i=0;i<rs;++i){
            pq.push(make_shared<node>(i,0,heightMap[i][0]));
            pq.push(make_shared<node>(i,cs-1,heightMap[i][cs-1]));
            visited[i][0] = true;
            visited[i][cs-1] = true;
        }
        
        for(int j=0;j<cs;++j){
            pq.push(make_shared<node>(0,j,heightMap[0][j]));
            pq.push(make_shared<node>(rs-1,j,heightMap[rs-1][j]));
            visited[0][j] = true;
            visited[rs-1][j] = true;
        }
        
        while(!pq.empty()){
            sp n = pq.top();
            pq.pop();
            for(int i=0;i<direction.size();++i){
                int row = n->row+direction[i][0],col = n->col+direction[i][1];
                if(row>=0&&row<rs&&col>=0&&col<cs&&visited[row][col]!=true){
                    visited[row][col] = true;
                    res +=(n->height - heightMap[row][col])<0?0:n->height-heightMap[row][col];
                    pq.push(make_shared<node>(row,col,max(n->height,heightMap[row][col])));
                }
            }
        }
        return res;
    }
private:
    class compare;//因为友元类在node类后面，所以需要先声明
    class node{
        friend class compare;
        friend int Solution::trapRainWater(vector<vector<int>>& heightMap);
        //friend bool compare::cp(const node,const node);
        int row,col,height;
        public:
            node(int row_,int col_,int height_):row(row_),col(col_),height(height_){}
    };
    class compare{
        public:
            bool operator()(const sp v1,const sp v2){
                return v1->height > v2->height;
            }
    };
int rs,cs;
};
